\subsection{Multiplicación por bloques}

    \def\model{ByBlocks}
    \def\analisisAmdahl{
    Podemos observar que el speed up teórico tiende al máximo speed-up
    mientras que el real nos muestra que no usa toda la paralelizacion ya que al
    pasar de 1 a 2 threads, el tiempo no cae a la mitad, y al pasar de 1 a 4 threads
    tampoco. Se puede ver que tiene un speed-up de casi 2 lo cual quiere decir que
    hace uso de la mitad.
    }
    \def\analisisGustafson{
    Podemos ver que estos resultados demuestran que la sección serie del
    problema se mantiene casi constante respecto de la sección paralela
    que varía en forma ascendente con el tamaño de los datos de entrada.
    Pero además podemos observar que hay mucha ineficiencia respecto del uso de
    la paralelización ya que al aumentar el trabajo en casi el doble usando
    dos procesadores debería tardar aproximadamente lo mismo. Sin embargo vemos
    que el tiempo paralelo se duplicó, lo cual muestra que hay un problema de
    comunicación al aumentar el paralelismo. Mas adelante explicaremos que el
    módulo Pool es ineficiente respecto del uso de recursos
    }
    \input{report/resultados_template.tex}
    \newpage
    \clearpage

\subsection{Multiplicación elemento por fila}

    \def\model{ElementByRowBlock}
    \def\analisisAmdahl{
    Podemos observar que el speed up teórico tiende al máximo speed-up
    mientras que el real nos muestra que no usa toda la paralelizacion ya que al
    pasar de 1 a 2 threads, el tiempo no cae a la mitad, y al pasar de 1 a 4 threads
    tampoco. Se puede ver que tiene un speed-up de casi 2 lo cual quiere decir que
    hace uso de la mitad.
    }
    \def\analisisGustafson{
    Podemos ver que estos resultados demuestran que la sección serie del
    problema se mantiene casi constante respecto de la sección paralela
    que varía en forma ascendente con el tamaño de los datos de entrada.
    Pero además podemos observar que hay mucha ineficiencia respecto del uso de
    la paralelización ya que al aumentar el trabajo en casi el doble usando
    dos procesadores debería tardar aproximadamente lo mismo. Sin embargo vemos
    que el tiempo paralelo se duplicó, lo cual muestra que hay un problema de
    comunicación al aumentar el paralelismo. Mas adelante explicaremos que el
    módulo Pool es ineficiente respecto del uso de recursos
    }
    \input{report/resultados_template.tex}
    \newpage
    \clearpage

\subsection{Multiplicación columna por fila}

    \def\model{ColumnByRow}
    \def\analisisAmdahl{
    Podemos observar que el speed up teórico tiende al máximo speed-up
    mientras que el real nos muestra que no usa toda la paralelizacion ya que al
    pasar de 1 a 2 threads, el tiempo no cae a la mitad, y al pasar de 1 a 4 threads
    tampoco. Se puede ver que tiene un speed-up de casi 2 lo cual quiere decir que
    hace uso de la mitad.
    }
    \def\analisisGustafson{
    Podemos ver que estos resultados demuestran que la sección serie del
    problema se mantiene casi constante respecto de la sección paralela
    que varía en forma ascendente con el tamaño de los datos de entrada.
    Pero además podemos observar que hay mucha ineficiencia respecto del uso de
    la paralelización ya que al aumentar el trabajo en casi el doble usando
    dos procesadores debería tardar aproximadamente lo mismo. Sin embargo vemos
    que el tiempo paralelo se duplicó, lo cual muestra que hay un problema de
    comunicación al aumentar el paralelismo. Mas adelante explicaremos que el
    módulo Pool es ineficiente respecto del uso de recursos
    }
    \input{report/resultados_template.tex}
    \newpage
    \clearpage

\subsection{Cblas e instrucciones vectorizadas}
    \def\text{Tiempo serie de multiplicación en segundos}
    \def\path{dgemm.png}
    \def\scale{.6}
    \input{report/image.tex}

    Podemos ver que \code{cblas} tiene una mejor performance que las instrucciones
    vectoriales. Por otro lado podemos ver que hay una mejora al usar las
    instrucciones vectoriales en el código \code{blocked\_dgemm\_sse} respecto del
    mismo código que no hace uso de las mismas.
    De esta manera vemos que \code{cblas} y las instrucciones vectorizadas
    aprovechan mucho mejor el hardware para la realización de la misma operación.
    También es cierto que el map-reduce hace uso de un módulo de \code{python}
    llamado \code{pool} que suma latencia al momento de dividir el trabajo ya
    que sufre mucho el costo de la comunicación entre procesadores. En el análisis
    de los resultados de explica con detalle el problema del módulo \code{pool}
    y se muestra una prueba de la diferencia considerable de performance entre
    \code{c}, \code{python} y \code{python usando pool}
