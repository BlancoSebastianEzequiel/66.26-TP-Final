Para calcular el speed-up real de Amdahl se utilizó la ecuación \code{(2)}, para
el speed-up teórico de Amdahl se utilizó la ecuación \code{(3)} y para el
speed-up Gustafson se utilizó la ecuación \code{(7)}
\subsection{Multiplicación por bloques}

    \def\model{ByBlocks}
    \def\analisisAmdahl{
    Se puede observar que el speed up teórico tiende al máximo speed-up,
    mientras que el real nos muestra que no usa toda la paralelizacion, ya que al
    pasar de 1 a 2 threads el tiempo no cae a la mitad, y al pasar de 1 a 4 threads
    no cae a la cuarta parte. Se puede ver que tiene un speed-up de casi 2 lo
    cual quiere decir que hace uso de la mitad de la paralelización.
    }
    \def\analisisGustafson{
    Se puede ver que estos resultados demuestran que la sección serie del
    problema se mantiene casi constante respecto de la sección paralela,
    que varía en forma ascendente con el tamaño de los datos de entrada.
    Pero además se puede observar que hay mucha ineficiencia respecto del uso de
    la paralelización, ya que al aumentar el trabajo en casi el doble y usar
    dos procesadores debería tardar aproximadamente lo mismo. Sin embargo, vemos
    que el tiempo paralelo se duplicó, lo cual muestra que hay un problema de
    comunicación al aumentar el paralelismo. Más adelante se explicará que el
    módulo Pool es ineficiente respecto del uso de recursos.
    }
    \input{report/resultados_template.tex}
    \newpage
    \clearpage

\subsection{Multiplicación elemento por fila}

    \def\model{ElementByRowBlock}
    \def\analisisAmdahl{
    Se puede observar que el speed up teórico tiende al máximo speed-up,
    mientras que el real nos muestra que no usa toda la paralelizacion, ya que al
    pasar de 1 a 2 threads el tiempo no cae a la mitad, y al pasar de 1 a 4 threads
    no cae a la cuarta parte. Se puede ver que tiene un speed-up de casi 2 lo
    cual quiere decir que hace uso de la mitad de la paralelización.
    }
    \def\analisisGustafson{
    Se puede ver que estos resultados demuestran que la sección serie del
    problema se mantiene casi constante respecto de la sección paralela,
    que varía en forma ascendente con el tamaño de los datos de entrada.
    Pero además se puede observar que hay mucha ineficiencia respecto del uso de
    la paralelización, ya que al aumentar el trabajo en casi el doble y usar
    dos procesadores debería tardar aproximadamente lo mismo. Sin embargo, vemos
    que el tiempo paralelo se duplicó, lo cual muestra que hay un problema de
    comunicación al aumentar el paralelismo. Más adelante se explicará que el
    módulo Pool es ineficiente respecto del uso de recursos.
    }
    \input{report/resultados_template.tex}
    \newpage
    \clearpage

\subsection{Multiplicación columna por fila}

    \def\model{ColumnByRow}
    \def\analisisAmdahl{
    Se puede observar que el speed up teórico tiende al máximo speed-up,
    mientras que el real nos muestra que no usa toda la paralelizacion, ya que al
    pasar de 1 a 2 threads el tiempo no cae a la mitad, y al pasar de 1 a 4 threads
    no cae a la cuarta parte. Se puede ver que tiene un speed-up de casi 2 lo
    cual quiere decir que hace uso de la mitad de la paralelización.
    }
    \def\analisisGustafson{
    Se puede ver que estos resultados demuestran que la sección serie del
    problema se mantiene casi constante respecto de la sección paralela,
    que varía en forma ascendente con el tamaño de los datos de entrada.
    Pero además se puede observar que hay mucha ineficiencia respecto del uso de
    la paralelización, ya que al aumentar el trabajo en casi el doble y usar
    dos procesadores debería tardar aproximadamente lo mismo. Sin embargo, vemos
    que el tiempo paralelo se duplicó, lo cual muestra que hay un problema de
    comunicación al aumentar el paralelismo. Más adelante se explicará que el
    módulo Pool es ineficiente respecto del uso de recursos.
    }
    \input{report/resultados_template.tex}
    \newpage
    \clearpage

\subsection{Cblas e instrucciones vectorizadas}
    \def\text{Tiempo serie de multiplicación en segundos}
    \def\path{dgemm.png}
    \def\scale{.6}
    \input{report/image.tex}

    Podemos ver que las instrucciones vectoriales en el código
    \code{blocked\_dgemm\_sse} tienen una mejora considerable respecto del mismo
    código sin vectorizar y \code{cblas}. Por otro lado vemos que \code{cblas}
    tiene una considerable mejor performance que el código
    \code{blocked\_dgemm\_sse} sin vectorizar.
    De esta manera vemos que \code{cblas} y las instrucciones vectorizadas
    aprovechan mucho mejor el hardware para la realización de la misma operación.
    También es cierto que el map-reduce hace uso de un módulo de \code{python}
    llamado \code{pool} que suma latencia al momento de dividir el trabajo ya
    que sufre mucho el costo de la comunicación entre procesadores. En el análisis
    de los resultados se explica con detalle el problema del módulo \code{pool}
    y se muestra una prueba de la diferencia considerable de performance entre
    \code{c}, \code{python} y \code{python usando pool}.
